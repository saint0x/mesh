use libp2p::{
    identify, noise, relay,
    swarm::{NetworkBehaviour, Swarm},
    tcp, yamux, SwarmBuilder,
};
use std::time::Duration;

use crate::config::Config;
use crate::errors::{RelayError, Result};

/// Composed network behaviour for the relay server
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "RelayBehaviourEvent")]
pub struct RelayBehaviour {
    pub identify: identify::Behaviour,
    pub relay: relay::Behaviour,
}

/// Events generated by RelayBehaviour
#[derive(Debug)]
pub enum RelayBehaviourEvent {
    Identify(Box<identify::Event>),
    Relay(relay::Event),
}

impl From<identify::Event> for RelayBehaviourEvent {
    fn from(event: identify::Event) -> Self {
        RelayBehaviourEvent::Identify(Box::new(event))
    }
}

impl From<relay::Event> for RelayBehaviourEvent {
    fn from(event: relay::Event) -> Self {
        RelayBehaviourEvent::Relay(event)
    }
}

/// Build and configure the libp2p swarm for the relay server
pub async fn build_swarm(config: &Config) -> Result<Swarm<RelayBehaviour>> {
    let keypair = load_or_generate_keypair()?;
    let peer_id = keypair.public().to_peer_id();

    tracing::info!(peer_id = %peer_id, "Initializing relay server");

    let swarm = SwarmBuilder::with_existing_identity(keypair)
        .with_tokio()
        // TCP transport with Noise encryption and Yamux multiplexing
        .with_tcp(
            tcp::Config::default(),
            noise::Config::new,
            yamux::Config::default,
        )
        .map_err(|e| RelayError::Transport(format!("Failed to configure TCP: {}", e)))?
        // QUIC transport (has built-in encryption)
        .with_quic()
        .with_behaviour(|keypair| {
            // Identify protocol for peer discovery
            let identify = identify::Behaviour::new(identify::Config::new(
                "/mesh-relay/1.0.0".to_string(),
                keypair.public(),
            ));

            // Circuit Relay v2 server configuration
            let relay = relay::Behaviour::new(
                keypair.public().to_peer_id(),
                relay::Config {
                    max_reservations: config.relay.max_reservations,
                    max_reservations_per_peer: config.relay.max_reservations_per_peer,
                    max_circuits: config.relay.max_circuits_per_peer,
                    max_circuits_per_peer: config.relay.max_circuits_per_peer,
                    max_circuit_duration: Duration::from_secs(
                        config.relay.max_circuit_duration_secs
                    ),
                    max_circuit_bytes: config.relay.max_circuit_bytes,
                    ..Default::default()
                },
            );

            Ok(RelayBehaviour { identify, relay })
        })
        .map_err(|e| RelayError::Transport(format!("Failed to build behaviour: {:?}", e)))?
        .with_swarm_config(|c| {
            c.with_idle_connection_timeout(Duration::from_secs(60))
        })
        .build();

    tracing::info!(
        max_reservations = config.relay.max_reservations,
        max_per_peer = config.relay.max_reservations_per_peer,
        max_circuits = config.relay.max_circuits_per_peer,
        circuit_duration_secs = config.relay.max_circuit_duration_secs,
        circuit_bytes = config.relay.max_circuit_bytes,
        "Relay configuration applied"
    );

    Ok(swarm)
}

/// Load keypair from file or generate new one
fn load_or_generate_keypair() -> Result<libp2p::identity::Keypair> {
    let keypair_path = dirs::home_dir()
        .ok_or_else(|| RelayError::Config("Cannot find home directory".into()))?
        .join(".meshnet")
        .join("relay_keypair.bin");

    if keypair_path.exists() {
        // Load existing keypair
        let bytes = std::fs::read(&keypair_path).map_err(|e| {
            tracing::error!(
                path = %keypair_path.display(),
                error = %e,
                "Failed to read keypair file"
            );
            e
        })?;

        let keypair = libp2p::identity::Keypair::from_protobuf_encoding(&bytes)
            .map_err(|e| RelayError::Config(format!("Invalid keypair file: {}", e)))?;

        tracing::info!(
            path = %keypair_path.display(),
            peer_id = %keypair.public().to_peer_id(),
            "Loaded existing relay keypair"
        );

        Ok(keypair)
    } else {
        // Generate new keypair
        let keypair = libp2p::identity::Keypair::generate_ed25519();

        // Create directory if it doesn't exist
        if let Some(parent) = keypair_path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        // Save keypair to file
        let bytes = keypair.to_protobuf_encoding()
            .map_err(|e| RelayError::Config(format!("Failed to encode keypair: {:?}", e)))?;

        std::fs::write(&keypair_path, bytes).map_err(|e| {
            tracing::error!(
                path = %keypair_path.display(),
                error = %e,
                "Failed to write keypair file"
            );
            e
        })?;

        tracing::info!(
            path = %keypair_path.display(),
            peer_id = %keypair.public().to_peer_id(),
            "Generated new relay keypair"
        );

        Ok(keypair)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_build_swarm() {
        let config = Config::default();
        let swarm_result = build_swarm(&config).await;
        assert!(swarm_result.is_ok(), "Swarm should build successfully");
    }

    #[test]
    fn test_keypair_generation() {
        // Clean up any existing keypair from previous test runs
        let keypair_path = dirs::home_dir()
            .expect("Cannot find home directory")
            .join(".meshnet")
            .join("relay_keypair.bin");

        // Remove existing keypair file to ensure clean state
        let _ = std::fs::remove_file(&keypair_path);

        // First call should generate keypair
        let keypair1 = load_or_generate_keypair().unwrap();
        let peer_id1 = keypair1.public().to_peer_id();

        // Verify the file was created
        assert!(
            keypair_path.exists(),
            "Keypair file should exist after generation: {}",
            keypair_path.display()
        );

        // Second call should load the same keypair
        let keypair2 = load_or_generate_keypair().unwrap();
        let peer_id2 = keypair2.public().to_peer_id();

        assert_eq!(peer_id1, peer_id2, "PeerID should be consistent across loads");

        // Clean up after test
        let _ = std::fs::remove_file(&keypair_path);
    }
}
