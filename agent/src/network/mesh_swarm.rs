// Mesh swarm implementation using libp2p with Circuit Relay v2 and DCUTR

use libp2p::{
    dcutr, identify, noise, relay,
    request_response::{
        Event as RequestResponseEvent, Message, OutboundRequestId, ResponseChannel,
    },
    swarm::{NetworkBehaviour, Swarm, SwarmEvent},
    tcp, yamux, Multiaddr, PeerId, SwarmBuilder,
};
use std::time::Duration;
use tracing::{debug, info, instrument, warn};

use super::events::{ConnectionInfo, ConnectionType, MeshEvent};
use super::job_protocol::{self, JobEnvelope, JobProtocol, JobProtocolConfig, JobResult};
use super::tensor_protocol::{self, TensorMessage, TensorProtocol, TensorProtocolConfig};
use crate::errors::{AgentError, Result};

/// Composed network behaviour for the mesh agent
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "MeshBehaviourEvent")]
pub struct MeshBehaviour {
    pub identify: identify::Behaviour,
    pub relay_client: relay::client::Behaviour,
    pub dcutr: dcutr::Behaviour,
    pub job_protocol: JobProtocol,
    pub tensor_protocol: TensorProtocol,
}

/// Events generated by MeshBehaviour
#[derive(Debug)]
pub enum MeshBehaviourEvent {
    Identify(Box<identify::Event>),
    RelayClient(relay::client::Event),
    Dcutr(dcutr::Event),
    JobProtocol(RequestResponseEvent<JobEnvelope, JobResult>),
    TensorProtocol(RequestResponseEvent<TensorMessage, TensorMessage>),
}

impl From<identify::Event> for MeshBehaviourEvent {
    fn from(event: identify::Event) -> Self {
        MeshBehaviourEvent::Identify(Box::new(event))
    }
}

impl From<relay::client::Event> for MeshBehaviourEvent {
    fn from(event: relay::client::Event) -> Self {
        MeshBehaviourEvent::RelayClient(event)
    }
}

impl From<dcutr::Event> for MeshBehaviourEvent {
    fn from(event: dcutr::Event) -> Self {
        MeshBehaviourEvent::Dcutr(event)
    }
}

impl From<RequestResponseEvent<JobEnvelope, JobResult>> for MeshBehaviourEvent {
    fn from(event: RequestResponseEvent<JobEnvelope, JobResult>) -> Self {
        MeshBehaviourEvent::JobProtocol(event)
    }
}

impl From<RequestResponseEvent<TensorMessage, TensorMessage>> for MeshBehaviourEvent {
    fn from(event: RequestResponseEvent<TensorMessage, TensorMessage>) -> Self {
        MeshBehaviourEvent::TensorProtocol(event)
    }
}

/// Configuration for the mesh swarm
#[derive(Debug, Clone)]
pub struct MeshSwarmConfig {
    /// Relay server multiaddress (e.g., "/ip4/127.0.0.1/tcp/4001")
    pub relay_addr: Multiaddr,

    /// Keep-alive interval for idle connections
    pub keep_alive: Duration,

    /// Job protocol configuration
    pub job_protocol: JobProtocolConfig,

    /// Tensor protocol configuration
    pub tensor_protocol: TensorProtocolConfig,
}

impl Default for MeshSwarmConfig {
    fn default() -> Self {
        Self {
            relay_addr: "/ip4/127.0.0.1/tcp/4001".parse().unwrap_or_else(|e| {
                tracing::error!("Failed to parse default relay address: {}", e);
                // Fallback to any valid multiaddr - this should never happen
                "/ip4/0.0.0.0/tcp/4001".parse().unwrap()
            }),
            keep_alive: Duration::from_secs(60),
            job_protocol: JobProtocolConfig::default(),
            tensor_protocol: TensorProtocolConfig::default(),
        }
    }
}

/// Builder for creating a mesh swarm
pub struct MeshSwarmBuilder {
    keypair: libp2p::identity::Keypair,
    config: MeshSwarmConfig,
}

impl MeshSwarmBuilder {
    /// Create a new builder with the given keypair
    pub fn new(keypair: libp2p::identity::Keypair) -> Self {
        Self {
            keypair,
            config: MeshSwarmConfig::default(),
        }
    }

    /// Set the relay server address
    pub fn with_relay_addr(mut self, addr: Multiaddr) -> Self {
        self.config.relay_addr = addr;
        self
    }

    /// Set the keep-alive duration
    pub fn with_keep_alive(mut self, duration: Duration) -> Self {
        self.config.keep_alive = duration;
        self
    }

    /// Build the mesh swarm
    #[instrument(skip(self), fields(peer_id = %self.keypair.public().to_peer_id()))]
    pub fn build(self) -> Result<MeshSwarm> {
        info!("Building mesh swarm");

        let job_protocol_config = self.config.job_protocol.clone();
        let tensor_protocol_config = self.config.tensor_protocol.clone();

        let swarm = SwarmBuilder::with_existing_identity(self.keypair)
            .with_tokio()
            // TCP transport with Noise encryption and Yamux multiplexing
            .with_tcp(
                tcp::Config::default(),
                noise::Config::new,
                yamux::Config::default,
            )
            .map_err(|e| AgentError::Network(format!("Failed to configure TCP: {}", e)))?
            // QUIC transport (has built-in encryption)
            .with_quic()
            .with_relay_client(noise::Config::new, yamux::Config::default)
            .map_err(|e| AgentError::Network(format!("Failed to configure relay client: {}", e)))?
            .with_behaviour(|keypair, relay_client| {
                // Identify protocol
                let identify = identify::Behaviour::new(
                    identify::Config::new("/mesh/1.0.0".to_string(), keypair.public())
                        .with_agent_version(format!("mesh-agent/{}", env!("CARGO_PKG_VERSION"))),
                );

                // DCUTR for hole-punching and direct connections
                let dcutr = dcutr::Behaviour::new(keypair.public().to_peer_id());

                // Job protocol for distributed task execution
                let job_protocol = job_protocol::new_job_protocol(job_protocol_config);

                // Tensor protocol for ring all-reduce communication
                let tensor_protocol = tensor_protocol::new_tensor_protocol(tensor_protocol_config);

                Ok(MeshBehaviour {
                    identify,
                    relay_client,
                    dcutr,
                    job_protocol,
                    tensor_protocol,
                })
            })
            .map_err(|e| AgentError::Network(format!("Failed to build behaviour: {:?}", e)))?
            .with_swarm_config(|c| c.with_idle_connection_timeout(self.config.keep_alive))
            .build();

        info!("Mesh swarm created successfully");

        Ok(MeshSwarm {
            swarm,
            config: self.config,
            relay_peer_id: None,
            ring_connections: None,
        })
    }
}

/// Ring neighbor connections for all-reduce communication
#[derive(Debug, Clone)]
pub struct RingConnections {
    /// Left neighbor in the ring (we receive from this peer)
    pub left_peer: PeerId,
    /// Right neighbor in the ring (we send to this peer)
    pub right_peer: PeerId,
}

/// Main mesh swarm struct
pub struct MeshSwarm {
    swarm: Swarm<MeshBehaviour>,
    config: MeshSwarmConfig,
    relay_peer_id: Option<PeerId>,
    ring_connections: Option<RingConnections>,
}

impl MeshSwarm {
    /// Create a new builder for constructing a mesh swarm
    pub fn builder(keypair: libp2p::identity::Keypair) -> MeshSwarmBuilder {
        MeshSwarmBuilder::new(keypair)
    }

    /// Get the local peer ID
    pub fn local_peer_id(&self) -> &PeerId {
        self.swarm.local_peer_id()
    }

    /// Connect to the relay server
    #[instrument(skip(self), fields(peer_id = %self.local_peer_id(), relay = %self.config.relay_addr))]
    pub fn connect_to_relay(&mut self) -> Result<()> {
        info!("Dialing relay server");
        self.swarm.dial(self.config.relay_addr.clone())?;
        Ok(())
    }

    /// Listen on the relay server (create a reservation)
    #[instrument(skip(self), fields(peer_id = %self.local_peer_id(), relay = %relay_peer_id))]
    pub fn listen_on_relay(&mut self, relay_peer_id: PeerId) -> Result<()> {
        info!("Creating relay reservation");

        // Listen on relay with p2p-circuit protocol
        self.swarm.listen_on(
            self.config
                .relay_addr
                .clone()
                .with(libp2p::multiaddr::Protocol::P2p(relay_peer_id))
                .with(libp2p::multiaddr::Protocol::P2pCircuit),
        )?;

        self.relay_peer_id = Some(relay_peer_id);
        Ok(())
    }

    /// Dial a peer through the relay
    #[instrument(skip(self), fields(local = %self.local_peer_id(), target = %peer_id))]
    pub fn dial_peer(&mut self, peer_id: PeerId) -> Result<()> {
        let relay_peer_id = self
            .relay_peer_id
            .ok_or_else(|| AgentError::Network("Not connected to relay server".to_string()))?;

        info!("Dialing peer through relay");

        // Construct relay circuit address: /ip4/.../tcp/.../p2p/<relay>/p2p-circuit/p2p/<target>
        let relay_addr = self
            .config
            .relay_addr
            .clone()
            .with(libp2p::multiaddr::Protocol::P2p(relay_peer_id))
            .with(libp2p::multiaddr::Protocol::P2pCircuit)
            .with(libp2p::multiaddr::Protocol::P2p(peer_id));

        debug!("Relay circuit address: {}", relay_addr);
        self.swarm.dial(relay_addr)?;
        Ok(())
    }

    /// Send a job request to a peer
    #[instrument(skip(self, job), fields(local = %self.local_peer_id(), target = %peer_id, job_id = %job.job_id))]
    pub fn send_job(&mut self, peer_id: PeerId, job: JobEnvelope) -> Result<()> {
        info!(
            workload = %job.workload_id,
            timeout_ms = job.timeout_ms,
            "Sending job to peer"
        );
        self.swarm
            .behaviour_mut()
            .job_protocol
            .send_request(&peer_id, job);
        Ok(())
    }

    /// Respond to a job request
    #[instrument(skip(self, result, channel), fields(job_id = %result.job_id))]
    pub fn respond_to_job(
        &mut self,
        channel: ResponseChannel<JobResult>,
        result: JobResult,
    ) -> Result<()> {
        info!(
            success = result.success,
            execution_time_ms = result.execution_time_ms,
            "Sending job result"
        );
        self.swarm
            .behaviour_mut()
            .job_protocol
            .send_response(channel, result)
            .map_err(|e| AgentError::Network(format!("Failed to send job response: {:?}", e)))?;
        Ok(())
    }

    /// Poll the swarm for the next event
    pub async fn next_event(&mut self) -> Option<MeshEvent> {
        use futures::StreamExt;

        loop {
            match self.swarm.next().await? {
                // Identify events
                SwarmEvent::Behaviour(MeshBehaviourEvent::Identify(event)) => match *event {
                    identify::Event::Received { peer_id, info, .. } => {
                        debug!(
                            peer_id = %peer_id,
                            protocol = %info.protocol_version,
                            agent = %info.agent_version,
                            "Peer identified"
                        );
                        return Some(MeshEvent::PeerIdentified {
                            peer_id,
                            protocol_version: info.protocol_version,
                            agent_version: info.agent_version,
                        });
                    }
                    identify::Event::Sent { .. } => {
                        debug!("Sent identify info");
                    }
                    identify::Event::Pushed { .. } => {
                        debug!("Pushed identify info");
                    }
                    identify::Event::Error { peer_id, error, .. } => {
                        warn!(peer_id = %peer_id, error = %error, "Identify error");
                    }
                },

                // Relay client events
                SwarmEvent::Behaviour(MeshBehaviourEvent::RelayClient(event)) => {
                    use relay::client::Event;
                    match event {
                        Event::ReservationReqAccepted {
                            relay_peer_id,
                            renewal,
                            limit,
                        } => {
                            if renewal {
                                info!(relay = %relay_peer_id, "Relay reservation renewed");
                            } else {
                                info!(relay = %relay_peer_id, limit = ?limit, "Relay reservation accepted");
                            }
                            return Some(MeshEvent::ReservationAccepted {
                                relay_peer_id,
                                renewal_timeout: Duration::from_secs(30),
                            });
                        }
                        Event::OutboundCircuitEstablished {
                            relay_peer_id,
                            limit,
                        } => {
                            debug!(relay = %relay_peer_id, limit = ?limit, "Outbound circuit established");
                        }
                        Event::InboundCircuitEstablished { src_peer_id, limit } => {
                            debug!(src = %src_peer_id, limit = ?limit, "Inbound circuit established");
                        }
                    }
                }

                // DCUTR events
                SwarmEvent::Behaviour(MeshBehaviourEvent::Dcutr(event)) => {
                    debug!("DCUTR event: {:?}", event);
                }

                // Job protocol events
                SwarmEvent::Behaviour(MeshBehaviourEvent::JobProtocol(event)) => {
                    match event {
                        RequestResponseEvent::Message { peer, message, .. } => match message {
                            Message::Request {
                                channel, request, ..
                            } => {
                                debug!(
                                    peer_id = %peer,
                                    job_id = %request.job_id,
                                    workload = %request.workload_id,
                                    "Received job request"
                                );
                                return Some(MeshEvent::JobReceived {
                                    peer_id: peer,
                                    job: request,
                                    channel,
                                });
                            }
                            Message::Response { response, .. } => {
                                debug!(
                                    peer_id = %peer,
                                    job_id = %response.job_id,
                                    success = response.success,
                                    "Received job result"
                                );
                                return Some(MeshEvent::JobCompleted {
                                    peer_id: peer,
                                    result: response,
                                });
                            }
                        },
                        RequestResponseEvent::OutboundFailure { peer, error, .. } => {
                            warn!(
                                peer_id = %peer,
                                error = ?error,
                                "Failed to send job request"
                            );
                            // We can return a JobSendFailed event but we don't have the job_id
                            // So we just log it for now
                        }
                        RequestResponseEvent::InboundFailure { peer, error, .. } => {
                            warn!(
                                peer_id = %peer,
                                error = ?error,
                                "Inbound job request failed"
                            );
                        }
                        RequestResponseEvent::ResponseSent { peer, .. } => {
                            debug!(peer_id = %peer, "Job response sent");
                        }
                    }
                }

                // Tensor protocol events
                SwarmEvent::Behaviour(MeshBehaviourEvent::TensorProtocol(event)) => match event {
                    RequestResponseEvent::Message { peer, message, .. } => match message {
                        Message::Request {
                            channel, request, ..
                        } => {
                            debug!(
                                peer_id = %peer,
                                job_id = %request.job_id,
                                layer = request.layer_idx,
                                step = request.step,
                                phase = ?request.phase,
                                "Received tensor message"
                            );
                            return Some(MeshEvent::TensorReceived {
                                peer_id: peer,
                                tensor: request,
                                channel,
                            });
                        }
                        Message::Response { response, .. } => {
                            debug!(
                                peer_id = %peer,
                                job_id = %response.job_id,
                                layer = response.layer_idx,
                                step = response.step,
                                "Tensor acknowledgment received"
                            );
                        }
                    },
                    RequestResponseEvent::OutboundFailure { peer, error, .. } => {
                        warn!(
                            peer_id = %peer,
                            error = ?error,
                            "Failed to send tensor message"
                        );
                        return Some(MeshEvent::TensorSendFailed {
                            peer_id: peer,
                            error: format!("{:?}", error),
                        });
                    }
                    RequestResponseEvent::InboundFailure { peer, error, .. } => {
                        warn!(
                            peer_id = %peer,
                            error = ?error,
                            "Inbound tensor message failed"
                        );
                    }
                    RequestResponseEvent::ResponseSent { peer, .. } => {
                        debug!(peer_id = %peer, "Tensor acknowledgment sent");
                    }
                },

                // Connection events
                SwarmEvent::ConnectionEstablished {
                    peer_id,
                    endpoint,
                    num_established,
                    ..
                } => {
                    let connection_type = if endpoint
                        .get_remote_address()
                        .to_string()
                        .contains("p2p-circuit")
                    {
                        ConnectionType::Relayed
                    } else {
                        ConnectionType::Direct
                    };

                    let num_connections = num_established.get();

                    info!(
                        peer_id = %peer_id,
                        address = %endpoint.get_remote_address(),
                        connection_type = ?connection_type,
                        num_established = num_connections,
                        "Connection established"
                    );

                    return Some(MeshEvent::PeerConnected {
                        peer_id,
                        connection_info: ConnectionInfo {
                            connection_type,
                            remote_addr: endpoint.get_remote_address().clone(),
                            num_established: num_connections,
                        },
                    });
                }

                SwarmEvent::ConnectionClosed {
                    peer_id,
                    cause,
                    num_established,
                    ..
                } => {
                    if let Some(error) = cause {
                        warn!(peer_id = %peer_id, error = ?error, remaining = num_established, "Connection closed with error");
                    } else {
                        info!(peer_id = %peer_id, remaining = num_established, "Connection closed");
                    }
                    return Some(MeshEvent::PeerDisconnected { peer_id });
                }

                // Listen events
                SwarmEvent::NewListenAddr { address, .. } => {
                    info!(address = %address, "Listening on new address");
                    return Some(MeshEvent::NewListenAddr { address });
                }

                // Dial events
                SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
                    if let Some(peer_id) = peer_id {
                        warn!(peer_id = %peer_id, error = %error, "Outgoing connection error");
                    } else {
                        warn!(error = %error, "Outgoing connection error");
                    }
                }

                SwarmEvent::IncomingConnectionError { error, .. } => {
                    warn!(error = %error, "Incoming connection error");
                }

                // Other events
                event => {
                    debug!("Swarm event: {:?}", event);
                }
            }
        }
    }

    /// Get the current relay peer ID
    pub fn relay_peer_id(&self) -> Option<PeerId> {
        self.relay_peer_id
    }

    /// Get a list of connected peers
    pub fn connected_peers(&self) -> Vec<PeerId> {
        self.swarm.connected_peers().copied().collect()
    }

    /// Check if connected to a specific peer
    pub fn is_connected(&self, peer_id: &PeerId) -> bool {
        self.swarm.is_connected(peer_id)
    }

    /// Set the ring neighbors for all-reduce communication
    #[instrument(skip(self), fields(local = %self.local_peer_id(), left = %left, right = %right))]
    pub fn set_ring_neighbors(&mut self, left: PeerId, right: PeerId) {
        info!("Setting ring neighbors");

        self.ring_connections = Some(RingConnections {
            left_peer: left,
            right_peer: right,
        });

        // Ensure connections are established to both neighbors
        if let Err(e) = self.swarm.dial(left) {
            warn!(peer_id = %left, error = %e, "Failed to dial left neighbor");
        }
        if let Err(e) = self.swarm.dial(right) {
            warn!(peer_id = %right, error = %e, "Failed to dial right neighbor");
        }

        info!("Ring neighbors set: left={}, right={}", left, right);
    }

    /// Get the current ring neighbors
    pub fn get_ring_neighbors(&self) -> Option<&RingConnections> {
        self.ring_connections.as_ref()
    }

    /// Clear ring neighbors
    pub fn clear_ring_neighbors(&mut self) {
        self.ring_connections = None;
        info!("Ring neighbors cleared");
    }

    /// Send a tensor message to a peer
    ///
    /// Returns an `OutboundRequestId` that can be used to correlate
    /// responses and track the request lifecycle.
    #[instrument(skip(self, tensor), fields(
        local = %self.local_peer_id(),
        target = %peer_id,
        job_id = %tensor.job_id,
        layer = tensor.layer_idx,
        step = tensor.step
    ))]
    pub fn send_tensor(&mut self, peer_id: PeerId, tensor: TensorMessage) -> OutboundRequestId {
        debug!(
            phase = ?tensor.phase,
            chunk_size = tensor.chunk_data.len(),
            "Sending tensor to peer"
        );
        self.swarm
            .behaviour_mut()
            .tensor_protocol
            .send_request(&peer_id, tensor)
    }

    /// Respond to a tensor request with an acknowledgment
    #[instrument(skip(self, channel, ack), fields(
        job_id = %ack.job_id,
        layer = ack.layer_idx,
        step = ack.step
    ))]
    pub fn respond_to_tensor(
        &mut self,
        channel: ResponseChannel<TensorMessage>,
        ack: TensorMessage,
    ) -> Result<()> {
        debug!("Sending tensor acknowledgment");
        self.swarm
            .behaviour_mut()
            .tensor_protocol
            .send_response(channel, ack)
            .map_err(|e| AgentError::Network(format!("Failed to send tensor response: {:?}", e)))?;
        Ok(())
    }

    /// Send tensor to right neighbor in the ring
    ///
    /// Returns an `OutboundRequestId` that can be used to correlate responses.
    /// Returns an error if ring neighbors are not set.
    #[instrument(skip(self, tensor), fields(
        local = %self.local_peer_id(),
        job_id = %tensor.job_id,
        layer = tensor.layer_idx,
        step = tensor.step
    ))]
    pub fn send_tensor_to_right(&mut self, tensor: TensorMessage) -> Result<OutboundRequestId> {
        let ring = self
            .ring_connections
            .as_ref()
            .ok_or_else(|| AgentError::Network("Ring neighbors not set".to_string()))?;

        let right_peer = ring.right_peer;
        info!(
            right = %right_peer,
            phase = ?tensor.phase,
            "Sending tensor to right neighbor"
        );

        Ok(self.send_tensor(right_peer, tensor))
    }

    /// Get the left neighbor peer ID
    pub fn left_neighbor(&self) -> Option<PeerId> {
        self.ring_connections.as_ref().map(|r| r.left_peer)
    }

    /// Get the right neighbor peer ID
    pub fn right_neighbor(&self) -> Option<PeerId> {
        self.ring_connections.as_ref().map(|r| r.right_peer)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mesh_swarm_builder() {
        let keypair = libp2p::identity::Keypair::generate_ed25519();
        let swarm = MeshSwarm::builder(keypair)
            .with_keep_alive(Duration::from_secs(60))
            .build();

        assert!(swarm.is_ok(), "Swarm should build successfully");
    }

    #[test]
    fn test_default_config() {
        let config = MeshSwarmConfig::default();
        assert_eq!(config.keep_alive, Duration::from_secs(60));
        assert!(config.relay_addr.to_string().contains("127.0.0.1"));
    }

    #[test]
    fn test_mesh_swarm_peer_id() {
        let keypair = libp2p::identity::Keypair::generate_ed25519();
        let expected_peer_id = keypair.public().to_peer_id();
        let swarm = MeshSwarm::builder(keypair).build().unwrap();

        assert_eq!(swarm.local_peer_id(), &expected_peer_id);
    }

    #[test]
    fn test_builder_with_custom_relay() {
        let keypair = libp2p::identity::Keypair::generate_ed25519();
        let custom_relay: Multiaddr = "/ip4/192.168.1.1/tcp/5000".parse().unwrap();

        let swarm = MeshSwarm::builder(keypair)
            .with_relay_addr(custom_relay.clone())
            .build()
            .unwrap();

        assert_eq!(swarm.config.relay_addr, custom_relay);
    }

    #[test]
    fn test_connected_peers_empty() {
        let keypair = libp2p::identity::Keypair::generate_ed25519();
        let swarm = MeshSwarm::builder(keypair).build().unwrap();

        assert_eq!(swarm.connected_peers().len(), 0);
    }
}
