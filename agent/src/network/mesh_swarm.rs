// Mesh swarm implementation using libp2p with Circuit Relay v2 and DCUTR

use libp2p::{
    dcutr, identify, noise, relay,
    swarm::{NetworkBehaviour, Swarm, SwarmEvent},
    tcp, yamux, Multiaddr, PeerId, SwarmBuilder,
};
use std::time::Duration;
use tracing::{debug, info, warn, instrument};

use crate::errors::{AgentError, Result};
use super::events::{MeshEvent, ConnectionInfo, ConnectionType};

/// Composed network behaviour for the mesh agent
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "MeshBehaviourEvent")]
pub struct MeshBehaviour {
    pub identify: identify::Behaviour,
    pub relay_client: relay::client::Behaviour,
    pub dcutr: dcutr::Behaviour,
}

/// Events generated by MeshBehaviour
#[derive(Debug)]
pub enum MeshBehaviourEvent {
    Identify(identify::Event),
    RelayClient(relay::client::Event),
    Dcutr(dcutr::Event),
}

impl From<identify::Event> for MeshBehaviourEvent {
    fn from(event: identify::Event) -> Self {
        MeshBehaviourEvent::Identify(event)
    }
}

impl From<relay::client::Event> for MeshBehaviourEvent {
    fn from(event: relay::client::Event) -> Self {
        MeshBehaviourEvent::RelayClient(event)
    }
}

impl From<dcutr::Event> for MeshBehaviourEvent {
    fn from(event: dcutr::Event) -> Self {
        MeshBehaviourEvent::Dcutr(event)
    }
}

/// Configuration for the mesh swarm
#[derive(Debug, Clone)]
pub struct MeshSwarmConfig {
    /// Relay server multiaddress (e.g., "/ip4/127.0.0.1/tcp/4001")
    pub relay_addr: Multiaddr,

    /// Keep-alive interval for idle connections
    pub keep_alive: Duration,
}

impl Default for MeshSwarmConfig {
    fn default() -> Self {
        Self {
            relay_addr: "/ip4/127.0.0.1/tcp/4001"
                .parse()
                .expect("invalid default relay address"),
            keep_alive: Duration::from_secs(60),
        }
    }
}

/// Builder for creating a mesh swarm
pub struct MeshSwarmBuilder {
    keypair: libp2p::identity::Keypair,
    config: MeshSwarmConfig,
}

impl MeshSwarmBuilder {
    /// Create a new builder with the given keypair
    pub fn new(keypair: libp2p::identity::Keypair) -> Self {
        Self {
            keypair,
            config: MeshSwarmConfig::default(),
        }
    }

    /// Set the relay server address
    pub fn with_relay_addr(mut self, addr: Multiaddr) -> Self {
        self.config.relay_addr = addr;
        self
    }

    /// Set the keep-alive duration
    pub fn with_keep_alive(mut self, duration: Duration) -> Self {
        self.config.keep_alive = duration;
        self
    }

    /// Build the mesh swarm
    #[instrument(skip(self), fields(peer_id = %self.keypair.public().to_peer_id()))]
    pub fn build(self) -> Result<MeshSwarm> {
        info!("Building mesh swarm");

        let swarm = SwarmBuilder::with_existing_identity(self.keypair)
            .with_tokio()
            // TCP transport with Noise encryption and Yamux multiplexing
            .with_tcp(
                tcp::Config::default(),
                noise::Config::new,
                yamux::Config::default,
            )
            .map_err(|e| AgentError::Network(format!("Failed to configure TCP: {}", e)))?
            // QUIC transport (has built-in encryption)
            .with_quic()
            .with_relay_client(noise::Config::new, yamux::Config::default)
            .map_err(|e| AgentError::Network(format!("Failed to configure relay client: {}", e)))?
            .with_behaviour(|keypair, relay_client| {
                // Identify protocol
                let identify = identify::Behaviour::new(identify::Config::new(
                    "/mesh/1.0.0".to_string(),
                    keypair.public(),
                )
                .with_agent_version(format!("mesh-agent/{}", env!("CARGO_PKG_VERSION"))));

                // DCUTR for hole-punching and direct connections
                let dcutr = dcutr::Behaviour::new(keypair.public().to_peer_id());

                Ok(MeshBehaviour {
                    identify,
                    relay_client,
                    dcutr,
                })
            })
            .map_err(|e| AgentError::Network(format!("Failed to build behaviour: {:?}", e)))?
            .with_swarm_config(|c| {
                c.with_idle_connection_timeout(self.config.keep_alive)
            })
            .build();

        info!("Mesh swarm created successfully");

        Ok(MeshSwarm {
            swarm,
            config: self.config,
            relay_peer_id: None,
        })
    }
}

/// Main mesh swarm struct
pub struct MeshSwarm {
    swarm: Swarm<MeshBehaviour>,
    config: MeshSwarmConfig,
    relay_peer_id: Option<PeerId>,
}

impl MeshSwarm {
    /// Create a new builder for constructing a mesh swarm
    pub fn builder(keypair: libp2p::identity::Keypair) -> MeshSwarmBuilder {
        MeshSwarmBuilder::new(keypair)
    }

    /// Get the local peer ID
    pub fn local_peer_id(&self) -> &PeerId {
        self.swarm.local_peer_id()
    }

    /// Connect to the relay server
    #[instrument(skip(self), fields(peer_id = %self.local_peer_id(), relay = %self.config.relay_addr))]
    pub fn connect_to_relay(&mut self) -> Result<()> {
        info!("Dialing relay server");
        self.swarm.dial(self.config.relay_addr.clone())?;
        Ok(())
    }

    /// Listen on the relay server (create a reservation)
    #[instrument(skip(self), fields(peer_id = %self.local_peer_id(), relay = %relay_peer_id))]
    pub fn listen_on_relay(&mut self, relay_peer_id: PeerId) -> Result<()> {
        info!("Creating relay reservation");

        // Listen on relay with p2p-circuit protocol
        self.swarm.listen_on(
            self.config.relay_addr
                .clone()
                .with(libp2p::multiaddr::Protocol::P2p(relay_peer_id))
                .with(libp2p::multiaddr::Protocol::P2pCircuit),
        )?;

        self.relay_peer_id = Some(relay_peer_id);
        Ok(())
    }

    /// Dial a peer through the relay
    #[instrument(skip(self), fields(local = %self.local_peer_id(), target = %peer_id))]
    pub fn dial_peer(&mut self, peer_id: PeerId) -> Result<()> {
        let relay_peer_id = self.relay_peer_id
            .ok_or_else(|| AgentError::Network("Not connected to relay server".to_string()))?;

        info!("Dialing peer through relay");

        // Construct relay circuit address: /ip4/.../tcp/.../p2p/<relay>/p2p-circuit/p2p/<target>
        let relay_addr = self.config.relay_addr
            .clone()
            .with(libp2p::multiaddr::Protocol::P2p(relay_peer_id))
            .with(libp2p::multiaddr::Protocol::P2pCircuit)
            .with(libp2p::multiaddr::Protocol::P2p(peer_id));

        debug!("Relay circuit address: {}", relay_addr);
        self.swarm.dial(relay_addr)?;
        Ok(())
    }

    /// Poll the swarm for the next event
    pub async fn next_event(&mut self) -> Option<MeshEvent> {
        use futures::StreamExt;

        loop {
            match self.swarm.next().await? {
                // Identify events
                SwarmEvent::Behaviour(MeshBehaviourEvent::Identify(event)) => {
                    match event {
                        identify::Event::Received { peer_id, info, .. } => {
                            debug!(
                                peer_id = %peer_id,
                                protocol = %info.protocol_version,
                                agent = %info.agent_version,
                                "Peer identified"
                            );
                            return Some(MeshEvent::PeerIdentified {
                                peer_id,
                                protocol_version: info.protocol_version,
                                agent_version: info.agent_version,
                            });
                        }
                        identify::Event::Sent { .. } => {
                            debug!("Sent identify info");
                        }
                        identify::Event::Pushed { .. } => {
                            debug!("Pushed identify info");
                        }
                        identify::Event::Error { peer_id, error, .. } => {
                            warn!(peer_id = %peer_id, error = %error, "Identify error");
                        }
                    }
                }

                // Relay client events
                SwarmEvent::Behaviour(MeshBehaviourEvent::RelayClient(event)) => {
                    use relay::client::Event;
                    match event {
                        Event::ReservationReqAccepted { relay_peer_id, renewal, limit } => {
                            if renewal {
                                info!(relay = %relay_peer_id, "Relay reservation renewed");
                            } else {
                                info!(relay = %relay_peer_id, limit = ?limit, "Relay reservation accepted");
                            }
                            return Some(MeshEvent::ReservationAccepted {
                                relay_peer_id,
                                renewal_timeout: Duration::from_secs(30),
                            });
                        }
                        Event::OutboundCircuitEstablished { relay_peer_id, limit } => {
                            debug!(relay = %relay_peer_id, limit = ?limit, "Outbound circuit established");
                        }
                        Event::InboundCircuitEstablished { src_peer_id, limit } => {
                            debug!(src = %src_peer_id, limit = ?limit, "Inbound circuit established");
                        }
                    }
                }

                // DCUTR events
                SwarmEvent::Behaviour(MeshBehaviourEvent::Dcutr(event)) => {
                    debug!("DCUTR event: {:?}", event);
                }

                // Connection events
                SwarmEvent::ConnectionEstablished { peer_id, endpoint, num_established, .. } => {
                    let connection_type = if endpoint.get_remote_address().to_string().contains("p2p-circuit") {
                        ConnectionType::Relayed
                    } else {
                        ConnectionType::Direct
                    };

                    let num_connections = num_established.get();

                    info!(
                        peer_id = %peer_id,
                        address = %endpoint.get_remote_address(),
                        connection_type = ?connection_type,
                        num_established = num_connections,
                        "Connection established"
                    );

                    return Some(MeshEvent::PeerConnected {
                        peer_id,
                        connection_info: ConnectionInfo {
                            connection_type,
                            remote_addr: endpoint.get_remote_address().clone(),
                            num_established: num_connections,
                        },
                    });
                }

                SwarmEvent::ConnectionClosed { peer_id, cause, num_established, .. } => {
                    if let Some(error) = cause {
                        warn!(peer_id = %peer_id, error = ?error, remaining = num_established, "Connection closed with error");
                    } else {
                        info!(peer_id = %peer_id, remaining = num_established, "Connection closed");
                    }
                    return Some(MeshEvent::PeerDisconnected { peer_id });
                }

                // Listen events
                SwarmEvent::NewListenAddr { address, .. } => {
                    info!(address = %address, "Listening on new address");
                    return Some(MeshEvent::NewListenAddr { address });
                }

                // Dial events
                SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
                    if let Some(peer_id) = peer_id {
                        warn!(peer_id = %peer_id, error = %error, "Outgoing connection error");
                    } else {
                        warn!(error = %error, "Outgoing connection error");
                    }
                }

                SwarmEvent::IncomingConnectionError { error, .. } => {
                    warn!(error = %error, "Incoming connection error");
                }

                // Other events
                event => {
                    debug!("Swarm event: {:?}", event);
                }
            }
        }
    }

    /// Get the current relay peer ID
    pub fn relay_peer_id(&self) -> Option<PeerId> {
        self.relay_peer_id
    }

    /// Get a list of connected peers
    pub fn connected_peers(&self) -> Vec<PeerId> {
        self.swarm.connected_peers().copied().collect()
    }

    /// Check if connected to a specific peer
    pub fn is_connected(&self, peer_id: &PeerId) -> bool {
        self.swarm.is_connected(peer_id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mesh_swarm_builder() {
        let keypair = libp2p::identity::Keypair::generate_ed25519();
        let swarm = MeshSwarm::builder(keypair)
            .with_keep_alive(Duration::from_secs(60))
            .build();

        assert!(swarm.is_ok(), "Swarm should build successfully");
    }

    #[test]
    fn test_default_config() {
        let config = MeshSwarmConfig::default();
        assert_eq!(config.keep_alive, Duration::from_secs(60));
        assert!(config.relay_addr.to_string().contains("127.0.0.1"));
    }

    #[test]
    fn test_mesh_swarm_peer_id() {
        let keypair = libp2p::identity::Keypair::generate_ed25519();
        let expected_peer_id = keypair.public().to_peer_id();
        let swarm = MeshSwarm::builder(keypair).build().unwrap();

        assert_eq!(swarm.local_peer_id(), &expected_peer_id);
    }

    #[test]
    fn test_builder_with_custom_relay() {
        let keypair = libp2p::identity::Keypair::generate_ed25519();
        let custom_relay: Multiaddr = "/ip4/192.168.1.1/tcp/5000".parse().unwrap();

        let swarm = MeshSwarm::builder(keypair)
            .with_relay_addr(custom_relay.clone())
            .build()
            .unwrap();

        assert_eq!(swarm.config.relay_addr, custom_relay);
    }

    #[test]
    fn test_connected_peers_empty() {
        let keypair = libp2p::identity::Keypair::generate_ed25519();
        let swarm = MeshSwarm::builder(keypair).build().unwrap();

        assert_eq!(swarm.connected_peers().len(), 0);
    }
}
